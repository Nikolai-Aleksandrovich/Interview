# 红黑树

将树中的链接分为两类：

* 红链接将两个2-节点连接起来构成一个3-结点
* 黑链接就是普通的链接

> 一种等价的定义：
>
> * 红链接都是左链接
>
> * 没有一个结点同时与红链接相连
>
> * 该树是完美平衡，从根节点到任意结点，经历的黑链接数相同
>
> 为了方便，定义红边指向的节点就是红色的，不然就是黑色

```java
public class RedAndBlackTree<Key extends Comparable<Key>, Value> {
    private static final boolean RED = true;
    private static final boolean BLACK = false;


    private Node node;

    private class Node{
        Key key;
        Value value;
        Node left;
        Node right;
        boolean color;
        int N;

        public Node(Key key,Value value,Node left,Node right,boolean color,int N){
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
            this.N = N;
        }

    }
    public boolean isRed(Node node){
        if (node == null){
            return false;
        }
        return node.color==RED;
    }
    
}
```

如果将一棵红黑树的红边画平，那么所有的空连接到根节点的距离都是相同的，将红链接的结点合并，得到的就是一棵2-3树

所以无论如何定义，红黑树都既是23树也是BST

### 旋转操作

某些操作会改变红黑树的平衡性，这就需要使用旋转来恢复平衡性

旋转操作可以保持红黑树的有序性和完美平衡性

左旋：当出现红色的右链接，或者两条红色链接相连，则把一条红色的右链接转化为左链接

左旋和右旋：

```
public Node leftRotate(Node h){
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        h.color = RED;
        x.N = h.N;
        h.N = 1+size(h.left)+size(h.right);
        return x;
    }
    public Node rightRotate(Node node){
        Node ans = node.left;
        node.left = ans.right;
        ans.right = node;
        ans.N = node.N;
        ans.color = node.color;
        node.color = RED;
        node.N = size(node.left)+size(node.right)+1;
        return ans;
    }
```

### 插入：

###### 向单个2-结点插入新键

一棵只含有一个2-结点的树：

* **当新键小于结点值**：直接插入新的新的红色边，意味着新节点为红色，为原节点的left结点
* **当新键大于节点值**：此时直接插入后，出现了右边的红色边，则需要左旋

###### 向树底部的2-结点插入新值

插入一个新键会在树的底部新增一个结点（为了保证有序性），并且新增的节点的边必然是红色的，如果是left link，那么直接完成，如果是right link，那么还需要一次左旋

###### 向一棵双键树中插入新键

* 0次--如果新键大于原树的两个键：

  因此他被连接到3-结点的右链接上，此时树是平衡的，将这个树转为2-3树，然后把红链接改为黑链接

* 1次--如果新键小于原来两个键：

  他被连接到3-结点的左链接上，出现了两条连续的红链接，，首先进行右旋，在把这颗树转为2-3树，将红链接转为黑链接即可

* 2次--如果新键在两个键之间：

  会产生两条相连的红链接，先将下层的红链接左旋，转为第二种情况，再将整体右旋，将红变黑即可

###### 颜色转换

颜色转换除了**将子节点的颜色由红转黑**以外，还要将**父节点从黑转红**，

这个操作的特点是**不会影响整棵树的黑色平衡性**

* **根节点总是黑色**

  在向一颗双键树插入新键的过程中，根节点可能变为红色，本质上，根节点变为红色，说明根节点是一棵3-树的一部分，所以在**每次插入的时候，都会把根节点设置为黑色**

* 向树的底部3-结点插入新键

  会送一个结点到父节点去（因为中间节点的链接变红了）

* 将红链接向上传递

  每次必要的旋转都会把一个红色结点上升，这对于父节点来看，就是插入了一个结点，就是继续把红链接转移到中间节点上

  **所以，在插入点到跟结点的路径下，进行这样的操作：**

  * 若right为红，left为black，那么左旋，
  * 若left为为红，left的left也为红，那么先右旋，再变色
  * 若左右都为红，则变色

实现：

```java
public void put(Key key,Value value){
        Node node = put(key,value,root);
        node.color = BLACK;
    }
    private Node put(Key key,Value value,Node node){
        if (node==null){
            return new Node(key,value,null,null,RED,1);
        }
        int cmp = key.compareTo(root.key);
        if (cmp>0){
            root.right = put(key,value,root.right);
        }else if (cmp<0){
            root.left = put(key,value,root.left);
        }else {
            node.value = value;
        }
        //注意这三个条件
        if (isRed(root.right)&&isRed(root.left)){
            flapColor(root);
        }else if (isRed(root.right)&&!isRed(root.left)){
            leftRotate(root);
        }else if (isRed(root.left)&&isRed(root.left.left)){
            rightRotate(root);
        }
        root.N = size(root.left)+ size(root.right)+1;
        return root;
    }
```

### 删除

删除更复杂，不仅要在删除后，构造临时的4-结点沿着查找路径向下变换，也要再分解遗留的4-结点向上进行变换

###### 自顶向下的2-3-4树

插入时，沿查找路径向下进行变换：**保证当前节点不是4-结点，这样树底才有空间进行插入**

* 如果根节点为4-结点，则转化为三个2-结点，树高+1
* 如果结点为4-结点，父节点为2-结点，则转化为3-结点和两个2-结点
* 如果结点为4-结点，父节点为3-结点，则转化为4-结点和2个2-结点
* 插入算法保证不会出现4-4-结点出现
* 底部也只会遇到2-或者3-结点

沿查找路径向上变换：**将之前创建的4-结点配平**

所以，对2-3-4树，需要：

* 将4-结点表示为由三个2-结点的平衡子树，连接均为红链接
* 向下的过程中，分解所有的4-结点，并且进行颜色转换
* 向上的过程，用旋转将4-结点配平

代码：

```java
public void put(Key key,Value value){
        Node node = put(key,value,root);
        node.color = BLACK;
    }
    private Node put(Key key,Value value,Node node){
        if (node==null){
            return new Node(key,value,null,null,RED,1);
        }
        //向下的过程中的分解4-结点
        if (isRed(root.right)&&isRed(root.left)){
            flapColor(root);
        }
        //比较的过程
        int cmp = key.compareTo(root.key);
        if (cmp>0){
            root.right = put(key,value,root.right);
        }else if (cmp<0){
            root.left = put(key,value,root.left);
        }else {
            node.value = value;
        }
        //注意这三个条件
        if (isRed(root.right)&&!isRed(root.left)){
            leftRotate(root);
        }else if (isRed(root.left)&&isRed(root.left.left)){
            rightRotate(root);
        }
        root.N = size(root.left)+ size(root.right)+1;
        return root;
    }
```

###### 删除最小键

从树底部删除一个3-结点可以直接删除，但是如果要删除一个2-结点，会破坏树的平衡性：

为了不会删除任何一个2-结点，要保证查找路径不会出现任何一个2-结点，这样变换：

* 沿着左链接向下进行变换，确保当前结点不是2-结点：
  * 如果根节点是**2结点**，且两个子节点都是**2结点**，那么就可以**转化为4-结点**
  * 否则，就要保障根节点的**左子节点不是2结点**，可以从兄弟节点**借一个来**
    * 如果当前节点的**左子节点不是2结点**，完成
    * 如果当前节点的**左子节点是2结点**，但当前结点的右子节点不是2-结点，那就将**左子节点的兄弟结点移动一个键**过来
    * 如果当前左子节点和左子结点的兄弟结点都是2-，将父节点的最小键，左子节点，最近的兄弟节点合并为一个4-结点，这样，父节点就从4到3或者从3到2

在遍历的过程中执行操作，即可得到一个含有最小键的3-或者4-结点，进行删除即可。

###### 删除操作

可以保证查找过程中，任意的当前节点不是2-结点：

* 要删除的结点在树的底部，那就直接删除
* 不在的话，用后继节点替代他的位置，

## 红黑树的性质

* 红黑树的所有操作都可以维持在对数级别
* 红黑树大小为N，那么高度不会超过2LogN
* 大小为N的红黑树中，根节点到任意节点的平均路径是logN



# 2-3查找树

平衡查找树的第一种思路

* 允许树中的一个节点保存多个键
* 一颗标准二叉树的节点为**2-节点**，含有一个键和两条链接
* 一颗3-节点，含有两个键和三个连接

> 定义：一颗2-3查找树，要么是一颗空树，要么包含这样的节点
>
> * 2-结点，含有一个键和两条链接。左侧树中节点全部小于自身，右侧树中的节点全部大于自身
> * 3-结点，含有两个键和三个连接，左侧树中节点全部小于左值，中间键指向的节点再左值右值之间，右侧树中的节点全部大于右值

一棵完美平衡的2-3查找树所有空连接到根节点的距离都是相同的，

### 查找操作：

查找操作递归进行，每次检查该点是否有对应的值，再根据该值和目标值的大小决定如果左右寻值

### 插入操作

插入前应该先进行查找，没找到在最后递归的的节点处进行插入操作

###### 向2-结点插入新建：

直接将该2-节点替换为3-节点

###### 向一颗只含3-结点的树插入新值：

* 首先修改原3-节点为4-节点
* 然后，将4-节点转为2-2-2-节点

###### 向一棵父节点为2-结点的3-结点插入新值

* 对Z的查找结束于3-结点
* 将3-结点更改为包含Z的4-结点
* 将2-结点修改为含有中键的3-结点
* 将4-结点分解为2个2-结点

###### 向一个父节点为3-结点的3-结点加入新值

* 对Z的查找结束于3-结点
* 将3-结点更改为包含Z的4-结点
* 将中间节点上移，将父节点修改为包含中间节点的4-结点
* 取决于父节点的父节点的构造，进行不同的操作
* 将本节点转为2个2-节点
* 将父节点修改为三个2-节点

### 局部变换

将一个4-节点分为一个符合规则的节点有6种情况

* 4-节点本身就是根节点：直接变为3个2-节点
* 4-节点父节点为2-节点：上移中位节点，本节点转为2个2-节点
* 4-节点父节点为3-节点：上移中位节点，本节点转为2个2-节点，再递归处理父节点

