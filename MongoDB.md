

## 加速与持久化

数据库中，写入速度与持久化之间是矛盾的，写入速度是对数据库进行增删改的速度，持久化是写操作被永久保存的保证级别

### MySQL的InnoDB

实现了写入速度与持久化之间的妥协，他是一个事务性存储引擎，InnoDB通过两个地方确保持久性：事务日志与内存缓存池

* 事务日志会立即同步到磁盘
* 内存缓存池会通过后台线程同步到磁盘

这样双写的原因随机IO比顺序IO慢很多，写入主数据文件是随机IO，而写入RAM就快很多，之后再允许同步到磁盘上，而事务日志写磁盘是顺序写入的，所以很快。

当意外关机时，InnoDB可以替换事务日志，并更新主数据文件，确保高级别持久性的同时，保持性能

### MongoDB的妥协

用户自己选择语义来决定如何维持速度与持久性之间的平衡，决定是否启动事务日志，是否再数据写入缓存之前就发送确认，是否接受确认

如果关闭日志，当断电关机时，就会出现数据不一致的情况，这种情况应该选择主从复制模式，让从服务器保证主服务器的数据完整性

## 分片

mongoDB自动进行分片，并且具有片键，依照片键进行插入查找

mongos是用户和集群的交互点，可以隐藏分片内部的复杂性，并向用户提供一个单服务器接口

mongos不存储数据，集群配置被保存在一组专门的mongod上，也叫配置服务器，包含了集群最完整可靠的信息以供人访问，分片，mongos进程和系统管理员

### 集群的构造

一个mongoDB集群包括：mongos进程，mongod进程，和存储实际数据的分片

### 选择片键

* 不要选小基数片键，如果因为频繁查询要选，要用组合片键
* 不要选择升序片键，因为热点会更偏
* 不要使用随机片键，片键最好作为索引

**好的片键**

* 准升序键加搜索键

  新数据的访问比老数据频繁，所以希望数据大致按照时间排序，但也会均匀分布，既可以把要读写的数据保存在内存中，也可以负载均匀的分散在集群里

  ```
  {coarselyAscending:1,search:1}
  #coarselyAscending用来控制数据局部化，search是一个常用的检索字段
  ```

  这样的组合片键中，coarselyAscending的每个值能对应几十个以上的数据块，search是进行查询的字段

## 文档：

**类似于数据库的行**

多个键和关联的值有序的放在一起就是文档，在JavaScript中：

```
{"greeting" : "Hello, world!", "foo" : 3}
```

* 文档的键/值是有序的，前后掉个过就不同了

* 文档中的值可以是双引号的字符串，也可以是其他几种数据类型

文档的键是字符串,可以是任意UTF-8字符:

* 不得含有\0,这表示结尾

* .与$有特别的用处

* _开头的键是保留的

注意:MongoDB中不可有重复的键

## 集合

集合就是一组文档,**类似于数据库中的表**

#### 集合是无模式

一个集合里边的文档是各式各样的,这两个文档可以存在于一个集合中

```
{"greeting" : "Hello,world!"}
{"foo" " 5"}
```

那么还有必要使用多个集合吗?

* 表表解耦
* 分割为子集合可以优化查询
* 方便索引
* 数据集中

#### 集合命名

* 不得为空字符串""
* 不能含有/0,这个字符表示结尾
* 不能以"system."开头
* 不能包含$

#### 子集合

使用"."字符按照命名空间划分为子集合blog.post+blog.user

### 数据库

多个文档组成集合,多个集合组成数据库,一个MongoDB可以包含多个独立的数据库,有独立的权限控制

命名要求:

* 不包含" ",.,/,\和\0
* 不能是空字符串"";
* 全部小写
* 最多64字节

这是因为数据库名最终会变成文件系统的文件

例如在cms数据库中使用blog.posts集合,那么就是cms.blog.posts

### 

## 启动MongoDB:

一般作为网络服务器运行,连接到该服务器并执行操作,要启动则要运行mongod可执行文件

默认数据目录:C:\data\db\,并使用27017端口,所以创建数据目录,并确保有写入权限

并且启动一个基本的HTTP服务器,监听28017

### MongoDB shell

### 运行shell

略

## 数据类型

### 基本数据类型

JSON仅包含6种数据类型:null,boolean,数字,字符串,数组,对象

MongoDB的文档类似于JSON,但是添加了一些数据类型:

* null

  ```json
  {"x" : null}
  ```

* boolean

  ```
  {"x" : true}
  ```

* 32位整数,被自动转换为64位浮点数

* 64位整数:shell使用一个特殊的内嵌文档显示

* 64位浮点数:shell中所有的数字都是这个类型

  ```
  {"x" : 3.14}
  {"x" : 3}//也是浮点数
  ```

* 字符串

  ```
  {"x" : "foobar"}
  ```

* 符号,转化为字符串

* 对象id,文档12字节的唯一id

  ```
  {"x" : ObjectId()}
  ```

* 日期,从标准纪元开始的毫秒数

  ```
  {"x" : new Date()}
  ```

* 正则表达式

  ```
  {"x" : /foobar/i}
  ```

* 代码

  ```
  {"x" : function(){/*...*/}}
  ```

* 二进制数据,由任意字节的串组成

* 最大值,BSON的特殊类型

* 最小值,BSON的特殊类型

* 未定义

  ```
  {"x" : undefined}
  ```

* 数组

  值的集合或者列表为数组

  ```
  {"x" : {"a","b","c"}}
  ```

* 内嵌文档

  ```
  {"x" : {"foo" : "bar"}}
  ```

### 数字

因为JavaScript只有一种数字类型(64位浮点数),MongoDB有三种数字类型(32,64,64),但默认情况下,shell中的数字被当作双精度数,当你从mongodb中取出一个32位整数,在用shell存进去之后,它就变成了浮点数,所以尽量不要在shell下覆盖整个文档

数字表示位双精度数的一个问题是:将64位整数存入,它会显示一个内嵌文档(近似的表示64位整数)

如果内嵌文档只有一个键,那么是准确存储,但如果有多个键,那就是近似存储

![image-20210701172208750](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210701172208750.png)

![image-20210701172315734](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210701172315734.png)

### 日期

Date对象用作MongoDB的日期类型,创建Date对象,会调用new Data而不是Date

### 数组

数组可以当作有序对象,也可以当作无序对象

```
{"things" : ["pie", 3.14]}
```

### 内嵌文档

把整个MongoDB文档作为另一个文档键中的一个值

```
{
	"name" : "Jhon Doe",
	"address" : {
		"Street" : "123 Park Street",
		"city" : "Any",
		"state" : "NY"
	}
}
```

### _id和ObjectId

所有MongoDB文档必须有一个_id键,这个键的值可以是任何类型,默认是ObjectId对象,每一个集合的 每个文档都有唯一的_ _id值

#### ObjectId

是_id的默认类型,不同机器都能用全局唯一的相同方法生成,使用12字节的存储空间

