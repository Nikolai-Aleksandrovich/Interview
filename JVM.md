并行：垃圾回收器多条线程同时进行垃圾回收，用户线程仍然在等待

并发：垃圾回收器线程和其他用户线程同时执行，可能会交替执行

# java内存区域与内存溢出异常

## 运行时数据区域

* 程序计数器：当前线程执行的字节码的行号指示器，在虚拟机中，字节码解释器工作就是通过改变这个这个计数器的值来选择下一条要执行的字节码指令，多线程情况下，线程不停的切换并分配处理器时间，每个线程都需要一个程序计数器来确定当前执行到哪一条字节码命令。
  * 对于java方法，程序计数器记录字节码指令地址
  * 对于native方法，则是undefine
  * 程序计数器没有OOM情况
* java虚拟机栈：为执行java方法服务，线程私有，生命周期与线程相同，描述java方法执行的内存模型：每个方法执行会创建一个栈帧，存储**局部变量表**、**动态链接**、**方法出口**，方法从调用到执行完成，就对应一个栈帧从入栈到出栈的过程
  * 局部变量表放编译器的各种基本数据类型、对象引用（一个指向对象的指针或代表对象的句柄）、return Address（指向字节码指令的位置）
  * long double会占2个局部变量空间slot，其余基本类型只占一个。
  * 局部变量表所需的内存空间在编译器进行分配，当进入一个方法，这个方法在帧中占多大局部变量空间可以确定
  * StackOver Flow Error：线程请求的栈深度大于虚拟机允许的深度
  * Out Of Memory Error：线程扩展虚拟机栈但无法申请到足够的内存
* 本地方法栈：为执行native方法服务，也会抛出Stackoverflow 和 OOM
* Java堆：
  * 内存中最大一块，所有线程共享，虚拟机启动就创建，存放对象实例
  * 可以叫做垃圾堆，因为堆是垃圾回收器管理的主要区域，GC使用分代回收，分为新生代和老年代
  * 可以分配在物理上不连续但逻辑上连续的内存空间
  * OOM：如果堆中没有内存完成实例分配，也没办法扩展
* 方法区
  * 各个线程共享，存储已经被虚拟机加载的类信息、常量、静态变量、编译后的代码，也成为永久代
  * 不需要连续内存，可以固定或者扩展大小
  * 垃圾回收关注：常量池的回收和类型的卸载
  * OOM：没有足够内存
* 运行时常量池：
  * 属于方法区，存放编译期间生成的字面量和符号引用，字面量和符号引用在类加载之后存放在方法区的运行时常量池，除了保存class文件中符号引用外，还有直接引用
  * 是动态的，并不是在编译期间预加载之后就不变更了。使用String的intern方法
  * OOM
* 直接内存：
  * JDK1.4加入的NIO，引入缓冲池和通道的IO系统，使用Native函数库直接进行堆外内存分配，使用存储在java堆中的DirectByteBuffer对象作为这块内存的引用。避免在java堆和native堆互相复制数据
  * 也会有OOM限制

### 对象如何创建

* 遇到一个new指令，首先检查这个指令是否在常量池中定位到一个类的符号引用，检查这个类是否已经加载、解析和初始化过，没有的话就必须进行加载解析初始化
* 类加载检查完成后，虚拟机为新生对象分配内存，内存大小在类加载后就可确定，分配空间等同于把一块内存从java堆中分配出来
  * 分配方式-指针碰撞：如果内存绝对规整，则用一个指针，左边为用过的内存，右边为空闲的内存，只需要移动指针即可
  * 分配方式-空闲列表：如果内存零散，则维护一个列表，记录哪些那些内存快可用，分配一块足够大的给对象即可
  * 考虑并发性：如果给A分配内存，指针还未修改，B拿着旧指针进行申请
    * 采用CAS搭配失败重试的方式保证更新的原子性
    * 本地线程分配缓存TLAB，将堆中的空间划分给每个线程，在不同的空间中进行
* 分配完后，虚拟机将分配的空间初始化为0值，保证了java对象实例在代码中不赋予初始值就可以直接使用，因为已经把空间初始化为0值
* 虚拟机设置对象信息：属于哪个类，类的源信息，对象的hashcode，GC分代，放在对象头
* 使用<init>方法初始化对象数值。

### 对象的内存布局

对象的内存分为：对象头、实例数据、对齐填充

* 对象头分为两部分：
  * Mark word：存储对象运行时的数据：hashcode、GC分代年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳
  * 类型指针：对象指向他的类元数据的指针，如果是个数组，还要包括数组长度
* 数据部分为：
  * 代码中定义的各种类型字段内容，顺序受到虚拟机分配策略影响，相同宽度的字段会被分配在一起，Longs/double ints shorts/chars bytes boolean、oops，父类的变量会出现在子类之前
* 对齐填充存在的原因是：对象的大小必须是8字节的整数倍，而对象头正是8字节的倍数。

### 对象访问定位

* java通过栈上本地变量表上的reference数据操作堆上的具体对象
* 句柄访问：java堆会划分一部分内存作为句柄池，引用存储了对象的句柄地址，而句柄包含了对象池中的对象实例数据和方法区的类型数据
* 直接指针访问：reference存储的指针指向java堆中的对象地址，包含了对象实例数据，而对象示例数据中有指针指向类型对象数据
* 讨论：
  * 句柄访问的优点：reference直接存储指向句柄池对应句柄的指针，句柄一个指针指向对象池中的对象实例数据，另一个指向对象类型信息。这样就算垃圾回收时被移动，也不会改变reference
  * 直接指针访问就是快，访问数据需要一次寻值，访问类型需要2次寻值

### 如何解决堆溢出

* 判断是出现内存泄漏还是内存溢出
  * 内存泄漏：查看泄露对象到GCRoots的引用链，找到泄露对象用何种路径到GCRoots的，找到泄漏代码的位置
  * 内存溢出：内存中的对象都活着，检查虚拟机的堆参数，能不能放大，再检查对象的生命周期持有时间等

### 解决虚拟机栈和本地方法栈溢出

* 什么时候会溢出：
  * 当线程请求栈的深度超过JVM允许的最大深度，则Stackoverflow
  * 虚拟机在扩展栈时无法申请到足够的空间，则OOM
* 这其实是一个问题的两种表述，当栈空间无法继续分配时，内存太小还是栈空间太大？
* 在单个线程下，无论是栈帧太大还是虚拟机栈容量太小，内存无法分配时，都会Stackoverflow
  * 原因：操作系统分配给每个进程的容量最大值有限制，对32位系统，最大值是2GB，虚拟机控制java堆和方法区的最大值，可以忽略程序计数器的大小，剩下的大小就是虚拟机栈和本地方法栈的上限，每个线程分配的虚拟机栈空间越大，那么建立线程的数量就少了。
  * 所以，调试的过程中，默认虚拟机栈的临时变量表深度可以达到2000+，如果还出现堆栈溢出，要查看错误堆栈、没问题的话，就要减少线程的数量，并且给线程分配更大的栈空间，减少最大堆。

### 方法区和运行时常量池溢出

* String.intern()方法是一个Native方法
  * 如果字符串常量池已经包含了一个等于这个String对象的字符串，则返回池中这个字符串的String对象。
  * 不然就将这个常量加入到常量池中，返回对这个常量的引用。
  * JDK1.6中，intern会把首次遇到的字符串常量复制到永久代中，并返回对这个常量的引用，在JDK1.7中，会记录首次遇到的字符串常量的引用
* 方法区存放类的源信息，类名、属性、访问修饰符、字段描述、方法描述等，填满的方法就是生成大量无法回收的类

# 垃圾回收器与内存回收策略

## 如何判断对象已经死？

### 引用计数算法：

* 对象维护一个计数器，每当一个地方引用自己，+1，引用失效，-1，当该值为0，则可以回收
* 不科学，存在相互引用的可能，比如dogA.father = dogB,dogB.father = dogA，则无法回收两个对象。但JVM不用这种方法

### 可达性分析算法

* 使用一系列叫GCRoots的对象作为起始点，从这些节点向下搜索，走过的路径作为引用链，当GCRoots到这个对象不可达，那么这个对象可以被回收。
* 可以作为GCRoots的有：
  * 虚拟机栈中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈中JNI引用的对象

引用分为四种类型：

* 强引用：Object obj = new Object（）
* 软引用：还有用但非必须的对象，在系统要发生内存溢出异常之前，会把这些对象进行第二次回收，当回收后还没有内存可用，那么才抛出OOM
* 弱引用：被弱引用的对象只能生存到下一次垃圾回收前，然后被回收
* 虚引用：虚引用导致这个对象被回收时会受到一个通知

要真正判断对象死亡，要分为两次标记：

* 如果对象在可达性分析后发现，没有与GCRoots相连，那么就进行一次标记并筛选，判断是否应该执行finalize方法，如果对象未覆盖finalize，或者这个方法被虚拟机调用过，那么就没有必要执行finalize方法
* 如果认为有必要执行finalize方法，那么就放到一个FQueue队列中，稍后有一个低优先级的Finalize线程执行，但不承诺会等待，这是为了避免永久等待，使GC崩溃，稍后会堆FQueue进行第二次标记，如果此时对象还没有被引用，那么就会被回收。
* finalize方法只会被执行一次

#### 回收方法区：

* 方法区的垃圾回收负责不用的类和废弃常量，回收效率低
* 如何判断属于一个无用的类：
  * Java堆不存在任何该类的实例
  * 该类的类加载器已经被回收
  * java lang Class没有在任何地方被引用。无法在任何方法反射访问该类的方法

## 垃圾回收器算法

### 标记清除算法：mark sweep

* 首先标记所有需要回收的对象，然后第二次统一清除，效率不高，产生很多碎空间

### 复制算法Copying

* 将内存永远分为两半，只使用其中一半，当一半全部分配之后，就将所有还在使用的对象复制到另外一篇内存，清空原内存。
* 这样只用了一半内存，但避免了碎空间，但是复制本身也很费时间

### 标记整理算法Mark Compact

* 先进行标记，然后将存活的对象移动到内存的一侧，直接清理掉边界以外的内存即可。

### 分代算法

* 将内存划分为几块，新生代每次回收都会死亡80%以上，可以进行复制算法。老年代存活率高，使用标记清理算法或者标记整理算法

## HotSpot的算法实现

### 枚举根节点：

* 比如GCRoots找引用链，逐个检查全局引用和执行上下文，很费时间，分析工作必须在一个全局一致性的情况下进行，可能会导致全局停顿来进行可达性检查，停止所有线程。
* 使用OopMap数据结构，来告知GC哪些地方存在对象引用

### 安全点

* 程序运行的过程中，在安全点停顿并进行GC，这个点也存储着OopMap，记录语句的信息。
* 如何在GC发生时，让程序运行时的线程跑到安全点在停下来：
  * 抢先式中断：GC发生时，先把所有线程停下来，然后让没有到安全点的线程跑到安全点
  * 主动式中断：GC需要中断时，设置一个标志，当线程轮询得到这个标识，那么就把自己终端挂起

### 安全区域

* 加入程序没有进行执行，比如线程进入了Block或者Sleep状态，安全区域就是指，在这个区域中都是静态的，进行GC是安全的
* 当线程执行到安全区域的代码，首先表示自己进去安全区，当线程离开安全区，要检查GC是否完毕，不然就要等待

## 垃圾回收器

### Serial收集器：串行GC

* 用于新生代和老年代，是一个单线程的收集器，在进行收集的过程中，其他线程必须停止到safe point，直到它收集完毕，
* 没有线程交互的开销
* 新生代使用复制算法，老年代使用标记整理算法

### ParNew收集器：并行GC

* serial的多线程版本，使用多条线程进行垃圾回收
* 只有ParNew能与CMS配合
* 新生代使用复制算法，老年代使用标记整理算法

### Parallel Scavenge收集器：并行回收

* 新生代收集器，使用复制算法，并行多线程回收
* CMS尽可能缩短垃圾回收时，用户线程的等待时间，而Parallel Scavenge尽可能提高CPU的吞吐量，GC停顿时间时牺牲吞吐量和新生代空间带来的，当你要求停顿时间很少，降低吞吐量和新生代空间：那么原本每10s进行一次垃圾回收，回收停顿时间100ms，现在只要5s进行一次，停顿时间70ms。
* GC自适应调节策略：而且可以自己调节新生代大小等细节参数

### Serial Old收集器

* Serial收集器的老年代版本，单线程，使用标记整理算法。主要给Client模式下的虚拟机使用。
* 在Server模式下，和Parallel Scavenge收集器配合。或者作为CMS的后备方案，在发生Concurrent Model Failure使用

### Parallel Old收集器

* 是Parallel Scavenge的老年代版本，多线程和标记整理算法，关注吞吐量

### CMS（Concurrent Mark Sweep）收集器

* 目标是最短线程停顿时间，使用标记清除算法，分为四个阶段：
  * 初始标记：CMS initialmark
  * 并发标记： CMS concurrent mark
  * 重新标记：CMS remark
  * 并发清除：CMS concurrent sweep
    * 初始标记和重新标记还是需要停止一切线程
    * 初始标记：标记GCRoots能直接关联到的对象，很快
    * 并发标记进行GCRoots tracing
    * 重新标记是为了修正并发标记期间，用户程序继续运作而导致的标记产生变动的那一部分

* 特点：并发清除垃圾、低停顿，为老年代工作
* 缺点：
  * CMS收集器堆CPU资源很敏感，在CPU内核数较低的时候，并发阶段的标记和清除会很占资源
  * 无法处理浮动垃圾，可能出现Concurrent Mode Failure失败并导致一次Full GC，什么是浮动垃圾？由于CMS并发清理的阶段，还有线程运行，这段时间产生的垃圾没有标记，只能等待下一次标记再清除。所以也要留一部分内存空间给并发清理的其他线程运行，而不能让老年代把内存全部占用，如果预留的空间无法给其余线程运行，那么就会引发concurrent model failure
  * 基于标记清楚，会产生足量的碎片空间。当还有很大空间，但无法找到一片连续的空间供老年代分配对象，会触发内存整理，停止一切线程进行内存整理，使得停顿时间变长

### G1收集器

* 并发与并行，一方面缩短暂停其他线程进行GC的时间，另一方面可以避免一些暂停，让事件并发进行
* 分代收集：不区分新老，但是一人可以管理全局
* 空间整理：基于标记整理算法，不会产生内存碎片，也不会因为没有完整的空间而提前触发GC
* 可预测的停顿：将整个java堆分为若干个块，排名优先级，然后按照优先级对堆进行垃圾回收，但这样如何避免全局扫描？比如这个堆的对象引用了那个堆得对象？答案是对每个region建立remember set：虚拟机在发现程序对Reference类型的数据进行写操作，就会产生一个Write Barrier中断写操作，检查reference引用的对象是否在不同的region之中，有的话，就用cardtable把引用信息记录到被引用对象region的remember set中。在根节点扫描的时候，多扫描一个rememberset，就可以。
* G1收集器可分为：
  * 初始标记
  * 并发标记
  * 最终标记
  * 筛选回收
    * 初始标记：标记GCRoots能够关联到的对象，修改TAMS的值，让用户运行时，能够找到正确可用的Region来创建对象，要停顿线程，但是时间很短
    * 并发标记：从GCRoots寻找堆中对象进行可达性分析，将存活的对象找出，耗时长但是可以并发
    * 最终标记：修正因为并发而临时产生的垃圾转为非垃圾和非垃圾转为垃圾了，虚拟机把并发阶段的变化记录在了remember set log中，需要把remember set log中的变化迁移到remember set中，需要停顿，但也可以并行
    * 筛选回收：对region的回收成本和大小排序，根据用户选择的停顿时间指定回收计划，可以并发执行。

### GC日志

明白每一个块表示什么意思

## 内存分配规则

什么是minorGC？

发生在新生代的GC，因为java对象大部分短命。所以新生代GC很频繁，而且新生代GC很快

什么是Major GC或者FullGC？

发生在老年代的GC，一般会同步发生MinorGC，而且老年代GC比年轻代GC慢10倍。

垃圾回收器和内存分配负责了如何给对象分配内存和从对象身上回收不用的内存

### 对象优先分配在Eden

* 对象首先分配在新生代Eden区，没有资源的话，就进行一次Minor GC，打印一次内存回收日志
* 分配担保机制：如果新生代没有空间，就把新生代之前的对象暂时move到老年代

### 大对象直接进老年代

* 大对象：需要连续大量空间存储的java对象，比如很长的字符串和数组
* 尽量避免创建较大的临时短命对象，较大的对象需要内存复制来整理内存，而且有可能会导致提前GC，所以直接让他进老年代

### 长期存活的对象进入老年代

* 每个对象有一个年龄计数器，如果第一次minor GC之后，他还在，并且能被Survivor容纳，将被一道Survivor空间，并且年龄为1，在survicor每一次生存都是年龄+1.当年龄大于15，就进入老年代

### 动态对象年龄判定

* 虚拟机并不是永远要求年龄必须达到maxtennringThreshold才能进入老年代，当Surivivor相同年龄的对象大小总和超过一半时，就要将年龄大于或者等于该值的对象直接进入老年代

### 空间分配担保

* 发生Minor GC之前，虚拟机先检查老年代最大可用连续空间是否大于新生代所有对象的总空间，是的话，minorGC可以确保安全。否的话，虚拟机检查是否允许担保失败，是的话，会继续检查老年代最大可用连续空间是否能放得下历次晋升到老年代对象的平均大小，大于则GC，小于则进行Full GC

# 虚拟机性能监控

导致OOM的因素：

* Java堆和永久代会占用较多内存，可能导致OOM

* 直接内存溢出，这部分内存属于堆外内存，而且无法主动GC，只有在FullGC的时候，他才能GC
* 线程堆栈，内存不足，无法纵向分配时（无法创建新的栈帧），抛出StackOverFlow，无法横向分配（无法创建新的线程），OOM
* Socket缓冲区，
* JNI代码

# 类加载器

### 类加载的时机

类被加载到虚拟机内存开始，到卸载出内存为止，生命周期包含：

* 加载
* 验证
* 准备
* 解析
* 初始化
* 使用
* 卸载

加载、验证、准备、初始化、卸载是按部就班的开始的，但是每一步都是互相交叉混合进行的，并不必要串行。而解析阶段可以放到初始化之后再开始。

* 什么时候需要开始加载一个类？有虚拟机决定，什么时候对类进行初始化？称为一个类进行主动引用，而其他引用称为被动引用。

  * 遇到new，getstatic、putstatic、invokestatic字节码指令：new一个对象，读取或者设置类的静态字段时、调用静态方法
  * reflect包进行反射调用
  * 初始化一个类，但发现他的父类未进行初始化
  * 虚拟机启动时，用户需要指定一个执行主类，虚拟机会先初始化主类
  * JDK1.7的动态语言支持，javalang.invoke.MethodHandle的解析结果出现REFgetstatic、putstatic、invokestatic，而且对应的类没有经过初始化，那就要先初始化

  

## 类加载的过程

### 加载：

在加载阶段，虚拟机完成三件事情：

* 通过类的**全限定名**获取定义此类的**二进制字节流**
* 将**字节流代表的静态存储结构**转化为**方法区的运行时数据结构**
* 内存中生成一个代表这个类的**java lang Class对象**，作为方法区中对这个类数据的**访问入口**

获取二进制字节流可以从很多地方获取，比如jar包，war包，可以动态计算

* 对于一个非数组的类加载器，你可以重写loadClass方法来定义类加载器来控制字节流的获取

* 对于数组的类加载器，数组类本身是有jvm创建，但是其中每个元素还是加载器去创建

  * 如果类中的元素是引用类型，那么类加载器优先按照正常的加载方式加载这个类，数组C将在**加载该组件类型的类加载器**的**类名称空间**上被标示
  * 如果不是引用类型，那么jvm会把数组C标记为与引导类加载器关联
  * 数组类型的可见性和组件类型的可见性一致，如果组件时基本类型，那么数组类型就是public

  加载完成后，获取的二进制字节流就加载到了虚拟机的方法区，具体的数据格式自定义，然后实例化一个java lang Class对象，作为访问入口。他虽然是对象，但是存储在方法区里

### 验证：

目的：确保Class中的字节流符合虚拟机的要求，因为Class文件不一定要java编译出来，而是可以有多个来源。

* 文件格式验证：是否符合Class文件格式，能被java虚拟机处理
* 元数据验证：保证字节码的信息符合java语言规范
* 字节码验证：确保程序语义合法且符合逻辑
* 符号引用验证：虚拟机将符号引用转化为直接引用，并且验证符号引用访问权限、全限定名是否能找到对应的类

### 准备阶段

* 正式为类变量分配内存，设置初始值（数据类型的0值），在方法区进行分配，仅仅包含类变量，不包含实例变量，实例变量在实例化的时候，分配在堆中
* 如果有Constant Value出现，就在准备阶段直接设置为该值

### 解析

解析是虚拟机将常量池的**符号引用**替换为**直接引用**的过程。符号引用一CONSTANT Class info等出现

* 符号引用：用符号 描述引用的目标，引用的目标也不一定要加载到内存中
* 直接引用：直接指向目标的指针，偏移量或者定位目标的句柄，和内存相关，引用的目标一定在内存中存在

解析的时机可以自由分配，必须在执行某些操作符号的字节码指令之前进行解析，可以决定在类加载器加载时就进行解析，还是在符号引用被使用是进行解析

* 除了invoke dynamic 对一个符号进行解析后，可能需要再次解析，所以设置一个缓存来存放已经被解析的符号，在运行时常量池有记录就直接引用。
* 对于invoke dynamic，因为这是动态语言支持，所以等待程序实际运行时，解析动作才开始

#### 类或者接口的解析

要把一个类D的符号引用N转为对于类C或者接口C的直接引用：

* 如果C不是一个数组类型，那么就把代表N的全限定名传递给D的类加载器来加载C，在这个过程中，由于元数据验证和字节码验证，可能要加载D类的相关类，若出现失败，那么解析失败
* C是数组类型，如果元素是对象，那么就引用的全限定名传递D的类加载器来加载C，接着虚拟机生成一个数组对象
* 进行符号引用验证，确定D对C有访问权限。

#### 字段解析：

* 要解析一个字段符号引用，要先对字段表class index的类或者接口的符号引用进行解析，出现异常则失败
* 步骤：
  * 如果C包含了字段名和描述符匹配的字段，则直接返回引用
  * 如果C包含了类/接口，就从下往上递归并查找有没有名称和描述符匹配的，有就返回直接引用
  * 查找失败
  * 如果成功返回，还要对字段进行权限验证

#### 类方法解析

* 首先解析类方法表class index中方法所属的类或者接口的符号引用，解析成功后会按照以下方法进行后续类方法搜索：
  * 类方法和接口方法符号引用的常量是分开的，如果在类方法表中发现了class index索引的C是一个接口，直接报错
  * 在类C中查找是否有简单名称和描述符都与目标匹配的方法，有的话直接返回这个方法的直接引用
  * 否则，在类C的父类中递归查找是否有名称和描述符匹配的方法，有的话返回
  * 在类C的接口中递归查找是否有名称和描述符匹配的方法，有的话说明C是一个抽象类，抛出异常
  * 否则查找失败
  * 如果有答案，则会进行权限验证，如果没有对应方法的查找权限，则抛出异常。

#### 接口方法解析

* 接口方法需要先解析出接口方法表的class index中索引的方法所属的类或者接口的符号引用，解析成功进行查找：

  * 如果接口方法表中的class index中索引C是类不是接口，抛出异常
  * 在接口c和父接口查找是否有名称和描述符匹配的方法，返回
  * 否则失败

  没有权限问题，因为接口所有方法默认public

### 初始化：初始化是执行<clinit>()的过程

* 初始化阶段正式执行类中定义的java代码，是执行<clinit>()方法的过程，为类变量和其他资源赋值
* <clinit>()的特点：
  * <clinit>()方法由编译器自动收集类中的类变量的赋值动作和静态语句块中的语句合并产生，编译器收集顺序由语句在源文件顺序决定，静态语句块只能访问到定义在静态语句块之前的变量，之后的变量可以赋值，但不能访问
  * 虚拟机保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕，所以java虚拟机中第一个执行<clinit>()的一定是Object
  * 父类的静态语句块要优先于子类
  * 如果没有静态语句块，也没有静态变量，那么就不用进行<clinit>()
  * 接口不可以定义静态代码块，但可以有静态变量，不需要对父接口进行初始化，而是再用到的时候才会做，所以实现一个接口，直到用的时候才会初始化父接口的静态变量
  * 如果多个线程同时初始化<clinit>()只有一个线程会成功，其他都会阻塞

## 类加载器

类加载器实现：通过一个类的全限定名获取此类的二进制字节流

### 类加载器：

* 类加载器和类一同确定这个类在java中的唯一性
* 比较两个类相等只有在经过同一个类加载器加载后才可比较，如果加载器不同，就算是同一个class文件，也不会相等，相等表示对象的equals，isInstance方法后相等，

### 双亲委派模型

* 虚拟机只有两种类加载器：启动类加载器是虚拟机的一部分、其他的加载器，独立于虚拟机，是抽象类java lang Classloader的子类

  * 启动类加载器：负责将存放在java home/lib目录或被Xbootclasspath指定的路径且虚拟机按照文件名识别（rt.jar）的类库加载到虚拟机内存中，无法被java代码直接引用，如果需要把加载请求委派给引导类加载器，设置为null即可
  * 扩展类加载器：负责java home\lib\ext下，或者被java.ext.dirs系统变量指定的类库，可以直接被java引用，由sun.msic.Launcher&ExtClassLoader实现
  * 应用类加载器：由sun.misc.Launcher&AppClassLoader，使用ClassLoader中getSystemClassLoader的返回值，负责加载用户类路径的类库，也是默认的类加载器。

  #### 类加载器的双亲委派模型：

  * 要求除了顶层的启动类加载器外，其它类加载器都要有自己的父类加载器，不是继承，而是组合。
  * 双亲委派模型工作过程：一个类加载器收到了类加载的请求，不会自己尝试加载这个类，而是交给父类加载器完成，最终所有的类加载器都会把加载请求传给顶层的类加载器，只有父类加载器无法完成加载（搜索范围内没有这个类），才会让子类加载
  * 优点：java类随着类加载器一起，具有了带优先级的层次关系，比如java lang Object，存放在rt jar，不管是哪一个类加载器加载这个类，最终都会委派给模型最顶端的类加载器，因此Object在各种加载器环境下都是同一个类。如果你自己编写一个java lang Object，放在ClassPath中，那可能会出现多个Object类，就算自己用自己的类加载器强行加载一个rt jar库中已经有的，但是自己编写的类，编译不会有错误，但会出现运行错误。
  * 代码：在java lang ClassLoader的loadClass方法中：
    * 步骤：
    * 先检查是否已经被加载过，没有加载则调用父类的loadClass方法，如果父类为空，就设置启动类加载器为父加载器
    * 如果父类加载失败，找不到这个类，就用自己的类加载器进行。

# 虚拟机字节码执行引擎

虚拟机：输入字节码，处理过程是对字节码进行解析，输出是执行结果。

## 运行时栈帧结构

* 栈帧是支持虚拟机进行方法调用和方法执行的数据结构，是数据区的虚拟机栈中的栈元素，栈帧存折方法的局部变量表、操作数栈、动态连接和方法返回地址，每一个方法从调用到结束，就是一个栈帧在虚拟机中入栈和出栈的过程
* 每一个栈帧包含局部变量表，方法返回地址，操作数栈、动态链接，这些在编译的时候已经确定了，所以栈帧的大小在编译时已经确定了，所以内存大小不会受到运行期的影响
* 一个线程的调用链很长，但是只有栈顶的栈帧才是有效的，当前栈帧，对应当前方法，所有字节码指令都对于当前栈帧进行操作。



### 局部变量表

* 局部变量表存储方法参数和方法内部定义的局部变量，编译成Class文件的时候，就确定了局部变量表的最大容量
* 在局部变量表中，最小单位是变量槽，可以使用32位的物理内存存储8中基本数据类型，对于64位的数据类型，使用两个slot（long，double），那两个连续的slot会不会产生线程安全问题？不会，因为这是在栈帧中进行的，是线程私有的数据
  * 8种包含boolean，byte，char，short，int，float，reference，returnAddress
  * 其中reference应该能：
    * 查找java堆中对象的数据起始地址索引
    * 查找对象所属的数据类型在方法区的存储类型
* 通过索引定位访问局部变量表。从0到局部变量表的最大slot，如果是32位大小的，索引就是位置，如果是64位数据类型的数据，那么使用索引x和x+1的数据。
* 方法执行时，使用局部变量表完成参数值到参数变量列表的传递，局部变量表的0位是传递实例方法所属对象实例的引用，就是this。
* slot可以重用，方法体中的变量不一定会覆盖整个方法体，如果计数器的值超出了某个变量的作用域，那么这个slot会交给别的方法使用，但可能会影响垃圾回收

特点：

* 没有赋初值的阶段，对于类变量，在准备阶段会赋予系统初始零值，在初始化阶段会赋予定义的值，因此即使没赋初值，只定义，也可以使用静态变量，但是对于局部变量，就不是，在编译期间发现。

###  操作数栈

* 后入先出的栈，最大深度在编译时写到max stack，深度不会超过最大深度，可以存放基本类型，占用1或者2个栈容量
* 方法刚开始执行，操作数栈为空，运行时，有各种字节码指令进行出栈入栈操作，      
* 允许两个栈桢重叠，共享某些信息

### 动态连接

* 每一个栈帧都有一个指向运行时常量池中该栈帧对应方法的引用，这个引用的目的是为了支持方法调用的动态链接，Class文件的常量池中有大量符号引用，字节码的方法调用引用指令以常量池中的符号引用作为参数，
  * 静态解析：符号引用的一部分在第一次使用或者类加载的时候进行解析，转化为直接引用
  * 动态连接：另外一部分将在每一次运行期间转化为动态引用。

### 方法返回地址

方法执行时，有两种方式退出：

* 正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者
* 异常完成出口：不会产生返回值，只要异常中没有搜索到匹配的异常处理器，就会退出

退出的操作：回复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值指向调用指令后边的指令

## 方法调用：确定被调用方法的版本

### 解析：

* 解析：调用目标必须确定。所有方法调用中，目标方法在Class文件中都是对一个常量池的符号引用，类加载阶段会把一部分符号引用转为直接引用，另一部分是动态连接，这个解析能成立的原因，是方法在程序运行之前有一个确定的调用版本，这个版本在运行期间不可变。
* 静态方法和私有方法是“编译可知，运行不可变”都适合在类加载过程中解析。
* java虚拟机提供5条方法嗲用字节码指令：
  * invokestatic
  * invokespecial
  * invokevirtual
  * invokeinterface
  * invokedynamic

非虚方法：能被invokestatic 和 incokespecial嗲用的方法，都可以在解析时确定版本，有：静态方法，私有方法，实例构造器，父类方法，这些在类加载时就能的对应方法的符号引用。还有final方法。如果不属于非虚方法，那就要用分派调用

### 分派：

#### 静态分派：

* 依照静态类型来定义方法执行版本的是静态分派，比如方法重载，发生在编译阶段，所以进行静态分派的动作不是虚拟机完成的，而是编译器。静态类型时编译期可知的，会根据参数的静态类型来决定采用哪个重载版本。

#### 动态分配：

* 适用于override，invokevirtual指令的解析步骤：

  * 找到操作数栈顶的第一个元素指向的对象的实际类型，C
  * 如果C中有常量中的描述符和简单名称都一样的方法，进行权限校验，返回这个方法的直接引用，不然报错
  * 否则按照继承关系从下向上进行查找父类
  * 没有则报错

  由于第一步在运行期确定接收者的实际类型，所以如果实际类型不一样，会把方法引用指向不同的类上，所以会产生不同。

### 单分派和多分派

### 虚拟机动态分派的实现

* 因为动态分派需要在类的方法元数据中搜索合适的目标方法，这是很费劲的一件事，所以在方法区建立虚方法表
* 如果某个方法在子类没有被重写，那么子类的方法地址入口和弗雷德方法地址入口是一样的，重写的话，子类的不一样。
* 相同签名的方法，在父类子类的虚方法表都应该有一样的索引号，当类型变换，只需要变更虚方法表就可以查找对应的方法入口地址
* 方法表在类的加载的连接阶段进行初始化。
* 除了方法表，也可使用内联缓存或者基于类型继承关系分析的守护内联进行。

### 基于栈的字节码解释执行引擎

执行java代码有两种：解释执行（解释器）和编译执行（编译器编译）

## 晚期运行优化

* 在部分虚拟机中，java程序通过解析器进行解释执行，当虚拟机发现某个方法或者代码块执行特别频繁，会在运行时，把这些代码编译成与本地平台相关的机器码，进行各种层次的优化，称为即时编译器JIT

* 为什么HotSpot虚拟机要由编译器和解释器并存？

  * 当程序需要快速启动和执行，解释器首先发挥作用，程序运行时，编译器把代码编译成本地代码可以获得更高的执行效率。当内存占用过大，可以用会解释器，解释器也可以当作编译器激进优化的退出口，进行逆优化退回到解释状态继续用解释器进行。

* 分层编译：编译解释的配合

  * 0层：程序解释执行，解释器不开启性能监控，可以触发1层
  * 1层：C1编译，将字节码编译为本地代码，进行简单可靠的优化
  * 2层，C2编译，将字节码编译为本地代码，但是耗时会长，而且会有激进优化

  

  ### 热点代码触发条件：

  * 被多次调用的方法：编译器对整个方法进行JIT编译优化
  * 被多次执行的循环体：编译器仍然会对整个方法进行编译，发生在方法执行过程之中，所以称为栈上替换OSR
  * 如何判断热点？
    * 基于采样：周期性检查每个线程的栈顶如果某个方法经常出现，就可以判断
    * 基于统计和计数：为每个方法或者代码块建立计数器（方法调用计数器和回边计数器），在HotSpot中就是当计数器突破阈值，就会触发计数
    * 
  * 方法调用计数器：统计方法被调用的次数，C/S：1500和10000
    * 当一个方法被调用时，查询这个方法是否有被JIT编译过的版本，存在的话，优先使用编译后的本地代码运行，不存在就将计数器+1，然后判断是否超过阈值，超过的话就提交一个编译请求，然后进入解释器进行执行，如果编译完成，这个方法的调用入口会被改为新的。下一次就是用编译的本地代码
    * 方法调用计数器的半衰期：一段时间方法被调用的次数如果超过一段时间也没有达到阈值，那么他就会减半。
  * 回边计数器：统计方法循环体的执行次数，当字节码遇到控制流向后跳转称为回边，目的就是为了触发OSR编译。
    * C模式：回边阈值：方法调用计数器*OSR比率/100
    * S模式：回边阈值：方法调用计数器*OSR比率-解释器监控比率/100
    * 模式：但遇到一条回边指令，先查找执行回边的代码片段有没有被编译过，没有的话就+1，然后判断有没有超出，超出就使用OSR进行编译，没有就继续解释

### 编译过程后台发生了什么？

* 对于Server Compiler：是一个简单的三段式编译，局部优化放弃全局优化
  * 阶段一：将字节码构建成高级中间代码，首先编译器进行基础优化：方法内联和常量传播，然后使用HIR表示代码值
  * 阶段二：在HIR上完成一些代码优化，将HIR转化为LIR
  * 阶段三：用线性扫描算法在LIR上分配寄存器，产生机器代码

## java内存模型

### 主内存与工作内存

* 内存模型的目标：定义程序中各个变量的访问规则，就是再虚拟机中将变量存储到内存和存储内存中去除变量的细节，这个变量包含了实例字段、静态字段、构成数组对象的元素，但是不包括局部变量和方法参数，这些是线程私有的。
* 进程具有自己的主内存，线程从主内存中读取所使用的变量的主内存副本拷贝（其实是字段和引用，而不是真的全拷过来），进行操作，然后回存，线程和线程无法直接用工作内存通信
* 主内存对应物理硬件内存，虚拟机会让工作内存优先存储与寄存器和高速缓存，这才是程序主要读写的地方。，主内存是堆中的对象实例，工作内存是虚拟机栈的一部分

### 内存交互：

* 主内存和工作内存的交互必须是原子的：

  * lock：作用于主内存，把一个变量标标记为一个线程独占
  * unlock:作用于主内存，释放锁定变量
  * read：作用于主内存，加载主内存的变量到工作内存
  * load：作用于工作内存，把read的值放入工作内存的变量副本
  * use：作用于工作内存，把工作内存的一个值传给执行引擎
  * assign：作用于工作内存，把执行引擎的值赋给工作变量
  * store：作用于工作内存，把工作内存的一个值赋给主内存
  * write：把一个store的值存到主内存

* 使用规则：

  * readload和storewrite不能单独出现
  * assign之后必须存储
  * 没有assign不能存储
  * 新的变量只能在主存中诞生
  * 一个变量只能被一个人锁
  * unlock之前先存储
  * 没锁别用unlock
  * lock后，必须清空工作内存的值，使用前必须重新加载访问

  ### volatile

  * volatile是虚拟机提供的轻量级的同步机制
  * 当一个变量定义为volatile就具备两种特性：
    * 保持此变量对所有线程的可见性，代表：一个线程修改了变量的值，新值对于其他线程是立即可知的。为什么普通县城不行？普通线程进行读取，修改，写回，另一个线程读取才可见修改。
      * 误解：因为volatile变量的改动对所有线程立即可见，那么volatile变量在并发现下是安全的，不能这么说
        * 原因：可以确认，volatile变量不存在一致性问题（在工作内存中，可以存在不一致，但是每次使用volatile变量前，必须进行刷新，所以认为不存在一致性）但是java运算并非原子操作，导致volatile变量在并发下不安全
          * 比如i++，是由四条字节码指令进行的，当getstatic把race的值取到操作栈顶上，是原子性的，但是iconst、iadd这些指令，其他线程可能会把race的值已经更改了，那么现在可能就在操作过期数据。所以putstatic可能会把过期的小数据插入
          * 另外，单条字节玛指令也不是原子操作，一条字节码进行解释执行需要多条代码才能实现语义，如果编译执行，可能转化为许多本地机器码进行，所以并不能保持一条字节码是原子操作
      * 所以不符合这两种情况，仍然需要加锁保证原子性：
        * 运算结果不依赖变量的当前值或者能够保证只有单一线程修改变量的值
        * 变量不需要与其他的状态变量参与不变约束
    * 禁止指令重排优化，普通变量会保证在该方法的执行过程中所有依赖赋值结果的地方能获取到正确的结果，不保证变量赋值操作的顺序和代码的执行顺序一样。因为线程的方法执行过程无法感知：线程内部表现为串行的语义
      * 硬件的角度说：指令重排就是，CPU允许将多条指令不按照程序规定的顺序分发给各电路单元处理，volatile变量的赋值建立了内存屏障，就不能把之后的语句放到屏障之前

* volatile好在哪里？
  * 读性能和普通变量一样，但是写性能会慢一些，因为他要建立内存屏障，保证处理器不发生乱序执行，开销比锁低
* 使用的特殊规则：
  * load与use关联进行刷新主存：只有T对V前一个动作执行load操作，T才能对V进行use，只有后一个动作是use，才能进行load，
  * assign和store关联
  * 先读取或assign的，先进行，要求volatile变量不会进行指令重排优化。

### 内存对于long和double的特殊规则

java内存模型要求 8个操作具有原子性，但是对于64位数据类型，就对64位数据的读写操作为两次32为的操作，那就不保证4load、store、read、write这5个操作的原子性，那么就可能让非volatile的数据具有非原子性，但是虚拟机尽量把64位数据变为原子性。

### 原子性、可见性、有序性

原子性：保证read load assign use store write是原子性的、如果需要更大规模的原子性，还可以使用lock和unlock满足这种需求，也就是synchronized

可见性：当一个线程更改了共享变量的值，其他线程就立即得知这个修改，除了volatile，java还有synchronized和final

* 同步块的规则：进行unlock时，需要先把值从工作内存刷新到主内存中
* final的规则：初始化构造完成，并且没有通过this把引用传递传递出去，其他线程可能访问到了”初始化到一半的对象“在其他线程就可以看到final的

有序性：如果在本线程观察，所有操作都是有序的（线程内表现为串行的语义），如果在一个线程观察另一个线程，所有操作都是无序的。（指令重排序优化和工作内存与主内存延迟）

* volatile禁止了指令重排序优化
* synchronized由”一个变量一个时刻只允许一个线程对其进行操作“保证有序。

### 先行发生原则

如果操作A发生早于操作B，那么A产生的操作能被B观察到。具体规则：

和时间运行顺序没有关系

* 程序运行次序：书写在前面的操作先行与在后边的
* 管程锁定规则：unloc先行发生于后边同一个锁的的lock
* volatile先写先行于读
* 线程操作先行于对他的终止操作
* 线程start先行于此线程的其他操作
* 线程的interrupt先行于该线程其他操作
* 对象初始化先行于finalize操作

### 线程实现

* java线程的所有关键方法都是native的，代表无法使用平台无关的手段实现。
  * 使用内核线程实现：直接由操作系统支持，由内核完成线程切换，通过操作调度器进行调度，将任务樱色到哥哥处理器上，。程序使用高级接口：轻量级进程来创建和管理
  * 使用用户线程：轻量级进程建立在内核上，需要进行系统调用，效率受到限制，所以使用完全建立在用户空间的线程库上的用户线程，用户线程的创建销毁都是在用户态中完成，比较低消耗，但所有的操作都需要用户进行，
  * 使用用户线程和轻量级线程配合
  * java线程实现：一条线程就映射到一条轻量级进程中，是一对一的线程模型
* 线程的5种状态
  * 新建new：创建但未启动，使用start()进入Runnable状态
  * 运行：runnable，可能正在执行，也可能等待资源分配
  * 无限制等待waiting：没有占用CPU资源，等待其他线程唤醒，使用Notify（），notifyAll（）进入运行状态
    * Object.wait
    * Thread.join
    * LockSupport.park
  * 限制等待Timed waiting：不会占用CPU资源，但一段时间后会唤醒
    * Thread.sleep
    * Object.wait(n)
    * Thread.join(n)
    * LockSupport.parkNanos()
    * lockSupport.parkUntil
  * 阻塞Blocked：等待一个排他锁，比如进入同步区域
  * 结束：终止的线程

## 线程安全和锁

线程安全：当多个线程访问一个对象，不用考虑线程运行调度和交替执行，也不用考虑同步和协调，也能得到正确的结果，那就是线程安全

### 线程安全从强到弱的变化：

* 不可变：只要一个不可变对象被正确的构建出来（不发生this引用逃离），就永远不会发生不一致的情况
* 绝对线程安全：

### 自旋锁和自适应自旋：

如果共享数据的锁定状态只持续很短一部分时间，就会释放锁，之后的线程就要来获取，那么就可以让那个线程先不要挂起等待，而是空转，以方便获取锁。自适应自旋是，一个锁对象自旋刚刚获得了锁，那么就很容易再次获得，就允许等待多次时间。如果多次失败，那就很难再次获得，就减少等待时间。

### 锁消除

在编译器进行优化的过程中，把不可能存在共享数据竞争的锁去掉，如果判断一段代码中，堆上的数据都不会逃逸出去而被其他线程访问，就可以认为是线程私有的。

### 锁粗化

最好的是将同步数据块越小越好减少并发，但如果加锁放锁的过程太多，而且很密集，也可以考虑把所的范围方法

### 轻量级锁

目的：在没有多线程竞争时，减少传统锁使用操作系统互斥量产生的性能消耗

* java虚拟机的对象头分为两部分
  * 第一部分存储对象自身的运行时数据，哈希码，GC分代数据，在不同的系统分别为32bit（25存储hashcode，4存储GC分代年龄、2存储所标志位1固定为0）和64bit，也叫Mark Word，
  * 第二部分存储指向方法区对象类型数据的指针，也存储数组长度
    * MarkWord根据对象的状态复用存储空间
      * 在代码进入同步块，如果该对象没有被锁定（所标记位为01），虚拟机首先在栈帧中建立一个锁记录的空间。存储锁对象当前的mark word的拷贝。
      * 虚拟机使用CAS操作将对象的Mark Word更新为指向Lock Record锁记录的指针，如果成功，那么就拥有了锁，锁标志位为00，如果失败，
    * 如果失败，检查当前Markword是不是指向当前线程的栈帧，如果是，就代表当前线程已经获取了锁，如果不是，则代表锁对象已经被抢占了
    * 如果有两条线程争用一个锁，那么这个锁就不再有效，要变为重量级锁
  * 解锁：使用CAS，如果对象的Markword仍然指向着线程的锁记录，那就用CAS把对象当前的mark word和县城做复制的markword替换回来，如果替换成功，那就同步了，如果失败，就要再释放锁的同时，唤醒被挂起的线程。

偏向锁：如果虚拟机启动了偏向锁，那第一次获取锁，虚拟机会把对象头的标志位设置为01，偏向模式，使用CAS把获取到这个对象的线程ID记录到MarkWord中，以后每次进入同步块，都不再进行同步，当另外一个线程获取，那么就取消偏向